复习：1. 分页器封装原理？

需要知道：

    当前第几页：pageNo
    一共有多少条数据：total
    每一页展示多少条数据：pageSize
    连续的页码数（一般为奇数 5 | 7）
    隐含条件：分页器有多少页：totalPage = Math.ceil(total / pageSize) 

计算连续页码数的起始与结束数字

判断： 

    总页数小于连续页码数：起始数为：1，结束数为：最后一页
    总页数大于连续页码数：起始数为：当前页码数 - parseInt(连续页码数 / 2)，结束数为当：前页码数 + parseInt(连续页码数 / 2)
    但会有bug:
    以连续页码数为5、总页数为10为例：
    当前页码为1时，起始数为：-1，结束数为：3
    当前页码为2时，起始数为：0，结束数为：4
    当前页码为9时，起始数为：7，结束数为：11
    当前页码为10时，起始数为：8，结束数为：12
    修改bug：
    当起始数小于1时，令起始数等于1，结束数等于连续的分页数
    当结束数大于最后一页时，令起始数等于最后一页数 - 连续页码数 + 1，结束数等于最后一页的页码数

给每个页码框及上、下页绑定点击事件，并当为第一页和最后一页的时候禁用按钮（disabled，true禁用，false启用）

判断什么时候要省略号跟前面的页码，什么时候不要（v-if）
    起始数字大于1，要前面的页码
    起始数字大于2，要前面的省略号
    结束数字小于最后一页，要后面的页码
    结束数字小于最后一页 - 1，要后面省略号

给当前页添加css样式：:class="{ 类名: 当前页 == 按钮上的数字 }"

浏览器存储功能：HTML5中新增的，本地存储和会话存储
本地存储：持久化的 -- 5M
会话存储：并非持久化的 -- 会话结束就消失

获取购物车的数据的时候，发现获取不到购物车里面的数据，是因为服务器不知道你是谁？

UUID临时游客身份

修改产品个数的时候需要函数节流

复习：
1.1 加入购物车
UUID：点击加入购物车的时候，通过请求头给服务器带临时身份给服务器，存储某一个用户购物车数据
会话存储、去存储产品的信息以及展示功能
1.2 购物车功能
修改产品的数量
删除某一个产品的接口
某一个产品的勾选状态切换

删除选中全部产品的操作
注意：没有一次删除很多产品的接口，但是有通过ID可以删除产品的接口（一次删除一个）
Promisr.all([p1, p2, p3])
p1 | p2 | p3 ：每一个都是Promise对象，如果有一个Promise失败，都失败；全部成功，才成功

登录与注册静态组件--（处理共用图片资源问题）
登录与注册功能（git），必须要会的技能
assets文件夹--防止全部组件公用的静态资源
在css中也可以使用@符，但是前面要加一个~

注册业务 | 登录业务中的表单验证先不处理

## 登录业务
1. 注册--通过数据库存储用户信息（名字 密码）
2. 登录--登录成功的时候，后台为了区分这个用户是谁，而下发的token（令牌：唯一的标识符）
一般登录成功后服务器会下发token，前台持久化存储token（带着token找服务器要用户信息进行展示）
3. token令牌理解
注意：vuex仓库存储数据--不是持久化的
持久化存储token

## 登录过后首页用户信息的展示
1. 当用户注册完成，用户登录（用户名+密码）向服务器发请求（组件派发action：userLogin），登录成功获取到token，存储于仓库当中（非持久化的），路由跳转到home首页
2. 因此在首页当中（mounted）派发action（getUserInfo）获取用户信息，以及动态展示header组件内容
3. 一刷新home首页，获取不到用户信息（token：vuex非持久化存储）
4. 持久化存储token
5. 存在问题1：多个组件展示用户信息需要在每一个组件的mounted中发请求
6. 存在的问题2：用户已经登录了，就不能够再回登录页面
7. 存在的问题3：用户没登录，就不能进入购物车页面

## 退出登录
1. 发请求清除掉服务器存储的token
2. 清除掉本地与用户相关的信息

## 导航守卫
1. 导航：表示路由正在发生改变。进行路由跳转
2. 守卫：可以想象成紫禁城守卫
比如：紫禁城住着皇帝、太后、嫔妃
全局守卫：只要路由发送变化，守卫就能监听到。相当于紫禁城大门的守卫（不管去见谁，都要排查）
路由独享守卫：相当于去 皇帝/太后/嫔妃 路上的守卫
组件内守卫：相当于去 皇帝/太后/嫔妃 门口的守卫

统一登录的账号
13700000000  111111